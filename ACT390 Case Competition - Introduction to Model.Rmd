---
title: 'ACT390 Case Competition: Introduction to Model'
author: "Basil, Teo, Bob, Jingru, Christine and Brandon"
date: "03/11/2021"
output: pdf_document
header-includes:
  \usepackage{fvextra}
  \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Main Question

Should we upgrade the material of our client's rooftops to a more resilient material? If so, under what conditions should we upgrade?

# Model Assumptions/Limitations

We will perform our calculations under the following assumptions/limitations. 

1. The maximum time frame we will consider in our analysis in $m-1$, where $m$ is the maximum roof age for a roof in a certain region.  

2. We will only consider houses that currently have three tab shingle rooftops.

3. The upgraded material will be laminated shingles. 

4. The useful life of a roof is not affected by repairs that happen during its lifetime. 

5. The distribution of roof ages is only affected by our decision to upgrade and the repair of fully depreciated roofs. The effect of customer retention on the overall distribution of roof age is negligible.

# Adjustable Parameters 

To obtain results from the model, input hypothetical values for each parameter. The meaning and limitations of the variables are indicated in the code comments. 

```{r}

#Note: For additional details on our model, refer to our slideshow.

s<-3750 #Roof size (integer values in the interval [250, 10000] only) 

lambda<-1/3 #Parameter for severity of hailstorms

t<-14 #Time frame we are analyzing. Measured from the time of the first hail storm. 

m<-15 #Maximum roof age of region

n<-1 #Hailstorms per year

P<-0.3 #Percent damage caused by first hail storm (as a decimal in the interval [0,1]). 

#Note: P is a known value at the time that we are making the decision.
```

# Damage Functions

These functions correspond to the ones described in the "Modelling Damage" slide. 

```{r}

#Note: g_k is the damage function for hail size from [k,k+1]. 

#The only exceptions are g_6 and h_8, which hold for all hail size greater than or equal to k. 

#Three Tab Shingles

g_0<-function(x){0.1*x}
g_1<-function(x){0.15*x-0.05}
g_2<-function(x){0.25*x-0.25}
g_3<-function(x){0.25*x-0.25}
g_4<-function(x){0.15*x+0.15}
g_5<-function(x){0.1*x+0.4}
g_6<-function(x){1}

#Laminated Shingles

h_0<-function(x){0.05*x}
h_1<-function(x){0.1*x-0.05}
h_2<-function(x){0.2*x-0.25}
h_3<-function(x){0.15*x-0.1}
h_4<-function(x){0.15*x-0.1}
h_5<-function(x){0.1*x+0.15}
h_6<-function(x){0.15*x-0.15}
h_7<-function(x){0.1*x+0.2}
h_8<-function(x){1}
```

# Minimum Damage for a Positive Cost to Insurance

The following code computes the minimum damage required for the damage cost to exceed the deductible. The results in this section will help determine the damage costs to the insurance company.

```{r}

#Cost Per Unit

c1<-3.5 #Three Tab Shingles
c2<-4 #Laminated

#Minimum Damage

d1<-750/(c1*s) #Three Tab Shingles
d2<-750/(c2*s) #Laminated

#Minimum Required Hail Size

#Three Tab Shingles

if (s>=2143) {lb_1<-d1/0.1} else if (858<=s & s<=2142) {lb_1<-(d1+0.05)/0.15} else if (268<=s & s<=857) {lb_1<-(d1+0.25)/0.25} else {lb_1<-(d1-0.15)/0.15}

if (s>=3750) {lb_2<-d2/0.05} else if (1250<=s & s<=3749) {lb_2<-(d2+0.05)/0.1} else if (536<=s & s<=1249) {lb_2<-(d2+0.25)/0.2} else if (289<=s & s<=535) {lb_2<-(d2+0.1)/0.15} else {lb_2<-(d2-0.15)/0.1}
```

# Integration

The following code caries out the integration described in the "Putting it All Together" slide.

```{r}

#PDF of Exponential

f<-function(x){lambda*exp(-lambda*x)}

#Three Tab Shingles Integrands

integrand_A0<-function(x){f(x)*(c1*s*g_0(x)-750)}
integrand_A1<-function(x){f(x)*(c1*s*g_1(x)-750)}
integrand_A2<-function(x){f(x)*(c1*s*g_2(x)-750)}
integrand_A3<-function(x){f(x)*(c1*s*g_3(x)-750)}
integrand_A4<-function(x){f(x)*(c1*s*g_4(x)-750)}
integrand_A5<-function(x){f(x)*(c1*s*g_5(x)-750)}
integrand_A6<-function(x){f(x)*(c1*s*g_6(x)-750)}

#Laminated Integrands

integrand_B0<-function(x){f(x)*(c2*s*h_0(x)-750)}
integrand_B1<-function(x){f(x)*(c2*s*h_1(x)-750)}
integrand_B2<-function(x){f(x)*(c2*s*h_2(x)-750)}
integrand_B3<-function(x){f(x)*(c2*s*h_3(x)-750)}
integrand_B4<-function(x){f(x)*(c2*s*h_4(x)-750)}
integrand_B5<-function(x){f(x)*(c2*s*h_5(x)-750)}
integrand_B6<-function(x){f(x)*(c2*s*h_6(x)-750)}
integrand_B7<-function(x){f(x)*(c2*s*h_7(x)-750)}
integrand_B8<-function(x){f(x)*(c2*s*h_8(x)-750)}

#Three Tab Shingle Integrals

A0<-as.numeric(integrate(integrand_A0, min(max(lb_1,0),1), 1)[1])
A1<-as.numeric(integrate(integrand_A1, min(max(lb_1,1),2), 2)[1])
A2<-as.numeric(integrate(integrand_A2, min(max(lb_1,2),3), 3)[1])
A3<-as.numeric(integrate(integrand_A3, min(max(lb_1,3),4), 4)[1])
A4<-as.numeric(integrate(integrand_A4, min(max(lb_1,4),5), 5)[1])
A5<-as.numeric(integrate(integrand_A5, min(max(lb_1,5),6), 6)[1])
A6<-as.numeric(integrate(integrand_A6, 6, 10000)[1])

#Laminated Integrals

B0<-as.numeric(integrate(integrand_B0, min(max(lb_2,0),1), 1)[1])
B1<-as.numeric(integrate(integrand_B1, min(max(lb_2,1),2), 2)[1])
B2<-as.numeric(integrate(integrand_B2, min(max(lb_2,2),3), 3)[1])
B3<-as.numeric(integrate(integrand_B3, min(max(lb_2,3),4), 4)[1])
B4<-as.numeric(integrate(integrand_B4, min(max(lb_2,4),5), 5)[1])
B5<-as.numeric(integrate(integrand_B5, min(max(lb_2,5),6), 6)[1])
B6<-as.numeric(integrate(integrand_B6, min(max(lb_2,6),7), 7)[1])
B7<-as.numeric(integrate(integrand_B7, min(max(lb_2,7),8), 8)[1])
B8<-as.numeric(integrate(integrand_B8, 8, 10000)[1])
```

# Expected Values

The integration above results in the following numerical results.

```{r}

#Expected Damage Cost to Insurance for Three Tab Shingles

e1<-sum(A0,A1,A2,A3,A4,A5,A6)

e1 

#Expected Damage Cost to Insurance for Laminated Shingles

e2<-sum(B0,B1,B2,B3,B4,B5,B6,B7,B8)

e2
```

# Factoring Depreciation

The following code computes the annual cost of replacing old roofs.

```{r}

#Average Cost to Replace Each Roof with Three Tab Shingles

if (s>=286) {c<-c1*s-750} else {c<-0.5*c1*s-250}

#Proportion of Roofs that Reach Maximum Age Each Year

p_i<-c()

for(i in 0:t-1){
  prop<-pbeta((m-i)/m, 1, 1.5)-pbeta((m-i-1)/m, 1, 1.5)
  p_i<-c(p_i, prop)
}

#Cost of Replacing Depreciated Roofs Per Year

dep_cost<-c*p_i
dep_cost
```

# Benefit to Insurance

The following code computes the expected benefits of upgrading. Both the savings per year and total savings are displayed. 

```{r}

#Expected Future Savings Per Year

expected_future_savings_i<-c()

for (i in 1:t) {
  repair_savings<-n*(e1-e2)*(0.95)^(i-1)
  depreciation_savings<-dep_cost[i]*(0.95)^(i-1)
  total<-repair_savings+depreciation_savings
  expected_future_savings_i<-c(expected_future_savings_i, total)
}

#Per Year Savings if we Upgrade

expected_future_savings_i

#Total Savings if we Upgrade

expected_future_total_savings<-sum(expected_future_savings_i)
expected_future_total_savings
```

# Minimum Damage to Justify Costs

The following code outputs the information necessary for us to do a cost benefit analysis. Moreover, the upgrade function will tell us whether or not an upgrade is worth it given the parameters inputted at the beginning.

```{r}

#Should we upgrade given a damage percentage P?

#Since our policy has a deductible, we have to consider multiple cases.

#P_min is the minimum amount of damage for an upgrade to be worth it given that the damage costs exceeds the deductible. d1 is the minimum damage required for repair costs to exceed the deductible. 

P_min<-max(min((s*c2-expected_future_total_savings)/(s*c1), 1),0)

#If damage is less than d1, then the repair cost is less than the deductible. In this case, our decision to upgrade should only consider upgrade costs and expected future savings.

#If damage is greater than d1, then the insurance company will be responsible for some of the repair costs. Therefore, our decision to upgrade should also consider these costs.

cbind(d1, P_min)

upgrade_cost<-s*c2-750
cbind(upgrade_cost, expected_future_total_savings)

upgrade<-function(p) {
  if (p<d1) return(upgrade_cost-expected_future_total_savings<0)
  else return(p>P_min)
}

upgrade(P)
```
